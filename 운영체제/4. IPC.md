## IPC ( Inter Process Communication )

하나의 컴퓨터 안에서 실행되는 프로세스 간에 발생하는 통신을 IPC라고 부릅니다.

멀티 프로세스에서 프로세스는 스레드와 달리 각자 독립적인 주소공간을 가지고 수행되기 때문에 서로간의 통신이 불가능하다고 생각할 수 있지만, IPC를 사용한다면 가능합니다. 이번 시간에는 IPC의 종류와 방법에 대해 알아보겠습니다.

  

우선 IPC의 종류로는 공유 메모리, 소켓, 파이프, 메시지 큐, 세마 포어 등이 있습니다.

  

그 중 주요한 것들만 몇 개 뽑아서 알아봅시다.

  

### 1. 공유 메모리

![](https://blog.kakaocdn.net/dn/b1S5DF/btsHybljiKf/FgKahSwSMBuCvgYMrK68Q1/img.png)

**여러 프로세스가 서로 통신할 수 있도록 메모리를 공유하는 것**을 말합니다. 어떤 매개체를 통해 데이터를 주고 받는 게 아니라, 메모리 자체를 공유하기 때문에 불필요한 데이터 복사와 같은 오버헤드가 발생하지 않기 때문에 가장 빠르다고 볼 수 있으며, 같은 메모리 영역을 여러 프로세스가 공유하기 때문에 읽고 쓰는 과정에서의 동기화가 필요합니다.

  

  

### 2. 소켓

![](https://blog.kakaocdn.net/dn/cOHQQY/btsHyXmkovc/bnj0MQq2dculgkYJUXX6U1/img.png)

**네트워크 인터페이스 (TCP, UDP, HTTP 등) 을 기반으로 통신하는 것**을 의미합니다. 본래 목적은 네트워크간 통신이지만, IPC에도 활용.

- 한 컴퓨터 내의 여러 프로세스간 통신이 아닌, 각각의 다른 컴퓨터의 프로세스간 데이터를 교환하기 위해 사용되며 양 PC가 서로 port를 정해 대화하기 때문에, 서버 - 클라이언트 구조를 가집니다. 

![](https://blog.kakaocdn.net/dn/oOo9O/btsHynFQRMg/qgmYLolfWW3DyJjKZXFrXk/img.png)

- 소켓을 사용하면 통신 시 이렇게 계층을 타고 내려가면서 송신을 하고, 송신받은 컴퓨터에서는 아래 계층부터 위로 올라가서 대상 프로세스가 수신을 하는 방식으로 IPC가 이루어집니다.

  

### 3. 파이프

파이프는 **네임드 파이프**와, **익명 파이프**로 나뉩니다. 파이프는 부모, 자식 프로세스간 통신을 위해 사용되며 다른 네트워크 상에서는 사용이 불가능 합니다. 파이프 내에 데이터 용량도 제한되어 있으며, 쓰기 프로세스가 읽기 프로세스보다 더 빠르게 데이터를 처리할 수 없다는 것이 특징입니다.

![](https://blog.kakaocdn.net/dn/byjkl1/btsHy6DkCuV/m5NeTVCrtOwMJEu9SVy2R0/img.png)

- **익명 파이프** : 프로세스 사이의 FIFO ( First In First Out, 먼저 들어온거 먼저 나가는 큐와 같은 구조 ) 기반의 통신채널을 만들어 통신하는 것을 의미합니다.
    - 파이프는 단방향 통신이기 때문에 만약 양방향 통신을 하고자 한다면 아래와 같이 두 개의 익명 파이프를 만들면 됩니다.

![](https://blog.kakaocdn.net/dn/GbY1x/btsHx1iKsNv/QL8rvWfjZjE3hjc5qF2hd0/img.jpg)

단방향 파이프 * 2

  

  

![](https://blog.kakaocdn.net/dn/blGROt/btsHxR1IabF/VVxKWDQvg0SWxhIc3xzfek/img.png)

네임드 파이프

- **네임드 파이프** : 익명 파이프에서 확장된 개념으로, 부모-자식 프로세스 뿐만 아니라 다른 네트워크 상에서도 통신할 수 있는 파이프를 의미합니다. 보통 서버용 파이프, 클라이언트용 파이프를 구분해서 동작.

  

> _익명 파이프와 네임드 파이프의 차이_  
> > 익명 파이프 : 부모-자식 프로세스간에서만 사용되며 네트워크 간 통신에서 사용 X.  
> > 네임드 파이프 : 부모-자식에서 확장되어 네트워크 간 통신에서도 사용 O

  

  

### 4. 메시지 큐

![](https://blog.kakaocdn.net/dn/cDJ1We/btsHyafDLc2/bK4KKllsOw0IYRMSck6VPK/img.png)

**메시지를 큐 자료구조 형태로 관리하는 버퍼를 만들어 통신하는 것**을 말합니다.

메시지 지향 미들웨어를 구현한 시스템(Message Oriented Middleware / MOM )을 구현한 시스템으로 아래와 같은 과정을 가집니다.

  

1. 프로세스가 메시지를 보내거나 받기 전 큐를 초기화.
2. 보내는 프로세스의 메시지는 큐에 복사되어 받는 프로세스에 전달.

  

#### 메시지 큐, 언제 사용하는가?

일반적인 클라이언트-서버 구조에서는 사용자가 요청을 하면 서버가 처리 후 즉각적으로 클라이언트에게 응답을 합니다.

그러나 메시지 큐에서는 소비자(클라이언트-서버 구조로 치면 서버)가 메시지를 어느 시점에 가져가서 처리하는 지 보장하지 않습니다.

  

따라서 클라이언트 입장에서는 언젠가는 메시지 큐에 넣어둔 데이터가 언제 처리되는지는 알 수 없습니다. 이러한 비동기적인 특성을 가진 메시지 큐는 애플리케이션에서 즉각적인 처리와 피드백이 필요한 요청에 대해서 사용하기보다는 부가적인 기능에 사용하는 것이 적합하다고 볼 수 있습니다.. 

  

예를 들면 비밀번호를 찾기 위해 또는 회원가입 인증을 받기 위한 이메일 수신을 요청했을 때, 요청하자마자 인증 메일이 오지 않는 것과 같이 사용자에게 어느정도의 응답지연이 허용되는 경우 메시지 큐가 사용됩니다.

  

#### 메시지 큐의 장점

- **비동기** : 메시지 큐는 프로세스의 완료를 기다리지 않고 동시에 다른 작업을 처리하는 비동기적 처리 방식이기 때문에, 큐에 넣어놓고 나중에 처리해도 된다는 거. 따라서 동기처리가 가지는 많은 데이터가 요청되는 경우에 대해서는 응답지연이 발생하지 않는다는 거
    - 부가적으로 비동기적 처리기 때문에 서비스간 결합도가 낮아지고, 결합도가 낮아지기 때문에 확장성도 좋아진다고 볼 수 있겠네요.
- **보장성** : 메시지 큐에 보관된 데이터는 결국에는 모두 처리가 된다는 확실한 보장을 제공한다는 거.

  

공유 메모리, 소켓, 파이프, 메시지 큐 이외에도 세마포어, 메모리 맵 등이 있지만, 기본적으로 IPC에 자주 사용되는 것들을 알아보았습니다. 다음에는 프로세스 간 통신, 스레드 간 통신에서 발생할 수 있는 경쟁상태에 대해 알아보고 이 경쟁 상태에 대한 해결책들을 공부해보겠습니다.
운영체제는 프로그램이 실행되어 프로세스가 되기 위해 필요한 메모리를 할당할 때 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당할 위치(메모리의 주소)를 정합니다. 이 때 메모리 할당 방식에는 크게 두 가지로 '연속할당'방식과 '불연속할당' 방식이 있습니다. 이번 포스팅에서 이 두 가지 방식에 대해 알아봅시다.

  
먼저 연속할당 방식입니다.

## 연속 할당 방식

![](https://blog.kakaocdn.net/dn/dax12i/btsHDUqn6MI/mUnw0zbZyIG4kDrOZUVW9k/img.png)

연속할당 방식

  

연속할당 방식은 메모리에 '연속적'으로 공간을 할당하는 것을 말합니다.

  

연속할당 방식은 고정분할 방식과 가변분할 방식으로 나눌 수 있습니다.

  

### 1. 고정분할 방식

고정 분할 방식은 물리적 메모리를 미리 같은 크기로 분할해서 할당하는 방법을 말합니다. 미리 나누어둔 분할에 하나의 프로세스를 적재해 실행시킬 수 있게 하는 방식입니다. 그런데 만약 분할한 크기보다 더 큰 메모리를 요구하는 프로그램이 들어오게 되면 어떻게 될까요?

![](https://blog.kakaocdn.net/dn/bJV269/btsHDdD4rAn/y2MjPK5Awk3NMY3IBMVde1/img.png)

분할 크기보다 큰 프로그램은 메모리에 적재되지 못하는 외부 단편화 문제

그림과 같이 2의 크기로 고정분할하게 되면 2보다 작거나 같은 프로세스들은 메모리에 적재될 수 있지만, 2보다 큰 프로세스는 메모리에 적재될 수 없게 됩니다. 이렇게 메모리에서 사용가능한 공간을 사용하지 못하게 되는 현상을 **"외부 단편화"** 라고 합니다!

![](https://blog.kakaocdn.net/dn/yaydO/btsHDjEdqN0/5GKKAFnQAfywfXPnBnyic1/img.png)

분할 크기보다 작은 프로그램이 메모리에 적재되는 경우 사용하지 않는 남는 공간이 발생하는 내부 단편화 문제

  

그렇다면 고정분할 방식에서는 외부 단편화 말고는 문제가 없을까요? 그렇지 않습니다.

만약 위 그림에서 P2가 요구하는 메모리 크기가 1이라고 해봅시다. 그러면 고정분할에 따라 할당받은 메모리의 크기는 2인데 1밖에 사용하지 못하게 되어 1의 남는 공간이 발생하죠? 이처럼 할당받았지만, 사용하지 않는 공간이 발생하는 것을 **"내부 단편화"**라고 합니다.

  

외부 단편화, 내부 단편화가 발생하게 되면 사용하지 않는 공간이 발생하게 되어, 메모리가 낭비되게 됩니다. 

  

### 2. 가변 분할 방식

가변 분할 방식은 고정분할 방식과 달리 프로그램의 크기에 따라 동적으로 할당하는 방법입니다.

![](https://blog.kakaocdn.net/dn/qc57N/btsHFar97Kl/FfTTSe1OF4Ca0kCgKKGVK0/img.png)

가변 분할 방식

- 동적으로 할당하기 때문에 내부 단편화 문제는 발생할 일이 없지만, 외부 단편화 문제는 여전히 발생할 수 있습니다.

이렇게 외부 단편화가 발생한 상태에서 이 빈 공간에 공간의 크기보다 큰 프로그램이 실행되는 경우 내부 단편화 문제가 발생합니다. 따라서 이 현상을 막기 위해서는 어떤 위치에 올릴 지 결정하는 것이 중요한데요, 대표적인 방법으로 3가지가 있습니다.

- **_최초적합(First fit)_** : 최상단 또는 최하단에서부터 들어갈 수 있는 홀을 찾으면 바로 할당하는 방식. 
    - 모든 공간을 탐색할 필요가 없으므로 오버헤드 발생 X. 시간적인 측면에서는 제일 효율적인 방식입니다
- _**최적적합(Best fit)**_ : 필요한 메모리 크기 이상인 공간 중에서 가장 작은 홀에 할당하는 방식. 
    - 모든 공간을 탐색해야 하기 때문에 오버헤드가 발생하지만 공간적인 측면에서는 제일 효율적입니다.
- **_최악적합(Worst fit)_** : 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당하는 방식. 가장 널널한 곳에 들어가기 때문에 내부 단편화 발생.
    - 마찬가지로 모든 공간을 탐색해야 하니 오버헤드도 발생하고 공간적인 측면에서도 제일 비효율적..

_세 가지 방식 모두 내부 단편화가 발생할 여지가 있으나, 최적적합이 가장 내부단편화가 작게 발생하고 그 다음으로 최초 적합, 그 다음으로 최악 적합이 내부 단편화가 크게 발생할 여지가 있습니다._

  

가변 분할 방식에서 발생하는 내부 단편화 문제를 해결하는 3가지 방법을 알아보았습니다. 그렇다면 외부 단편화 문제는 해결할 수 없을까요? 

  

메모리 컴팩션으로 해결할 수 있습니다! 

  

### 메모리 컴팩션이란?

![](https://blog.kakaocdn.net/dn/Yn4lz/btsHDTrt2AM/MXkATRsjXeQP9iENm8Itpk/img.png)

메모리 컴팩션

- 프로세스가 종료된 자리에서 생겨난 가용공간을 없애기 위해 적재된 프로세스들을 한쪽으롷 몰고 가용공간을 다른한쪽으로 모아서 하나의 큰 가용공간을 만드는 것을 "메모리 컴팩션"이라고 합니다.
- 이렇게 프로세스들을 한쪽으로 쭉 이동시켜, 위에 빈 공간을 만든다면 외부에 빈 조각이 생겨나는 외부 단편화 문제를 막을 수 있답니다.
- 하지만 이렇게 프로세스들을 이동시키는 것도 비용이 매우 많이 드는 작업입니다.

  

## 불연속 할당

**불연속 할당 기법**은 메모리를 연속적으로 할당하지 않는 방법으로 현대 운영체제에서 사용하는 방식입니다.

불연속 할당 기법은 프로그램에 필요한 메모리를 "쪼개어" 서로 다른 위치에 있는 메모리 공간에 할당하는 방식으로, 대표적으로 페이징 방식과 세그먼테이션 기법이 있습니다.

  

### 페이징 

![](https://blog.kakaocdn.net/dn/kTbaU/btsHESZAAcv/25h8ouR2TQwnjBjYuprwQK/img.png)

  

페이징은 프로세스를 할당할 때 **"동일한 크기"의 페이지 단위**로 나누어 메모리의 **"서로 다른 위치"에 프로세스를 할당**하는 방식입니다.

- 모든 프로세스를 일정한 크기로 나누어서 할당하기 때문에 홀의 크기가 균일하지 않아 발생하는 외부 단편화 문제는 없지만, 주소 변환을 페이지별로 해야 하기 때문에 주소 변환이 복잡해지는 단점이 있습니다.

> Q. 페이징에서 내부 단편화는 발생하지 않나요?  
> A. 발생할 수 있습니다. 페이징 사이즈가 2일때 5의 크기를 가진 프로그램을 페이징하면 2/2/1로 나눌 수 있어요. 이 때 마지막 페이지에서 (2-1)의 내부 단편화가 발생합니다.

  

### 세그먼테이션

![](https://blog.kakaocdn.net/dn/6NeBX/btsHE0QIzU3/QeClyX1PKrPl5P5hXfQPl1/img.png)

- **세그먼테이션 방식**은 페이지 단위가 아닌 의미 단위인 **Segment**로 나누는 방식입니다. 프로세스는 코드, 데이터, 스택, 힙 영역으로 나누어져서 메모리가 할당되는데 이러한 논리적인 영역을 **세그먼트**라고 합니다.
- 이 코드, 데이터 영역 등 세그먼트들 내부에서도 더 작은 세그먼트로 나눌 수 있어요. 
    - 코드영역에는 여러 함수들이 존재하는데 이 코드영역 전체를 세그먼트로 올리는 것이 아닌 a 함수 세그먼트, b함수 세그먼트와 같이 쪼개서 메모리에 할당합니다.
- 세그먼트를 메모리에 할당할 때는 페이지를 할당하는 것과 동일하지만 이 때 Segment Table이라는 주소와 크기를 담고 있는 테이블을 통해 메모리에 할당합니다.
- 프로세스의 영역별로 다른 주소에 메모리를 할당받기 때문에 공유와 보안 측면에서는 좋지만, 홀 크기가 균일하지 않아 발생하는 외부 단편화 문제가 있습니다.
- 영역별로 크기에 맞게 동적으로 할당하기 때문에 내부 단편화 문제는 발생하지 않는다는 점!

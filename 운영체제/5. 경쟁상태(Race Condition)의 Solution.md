![](https://blog.kakaocdn.net/dn/cSQfxj/btsHy0cmVy7/maxKVimwZXNFBhtwbNVb60/img.png)
  
시스템 안에서 여러 프로세스, 스레드가 실행될 때 함께 접근할 수 있는 자원이 있습니다. 이 자원을 **공유 자원(Shared Resource)**이라고 부르는데, 모니터, 프린터, 메모리, 파일, 데이터 등이 이에 해당합니다. 이 공유 자원에 대해 여러 프로세스나 스레드가 접근을 시도하면, 실행 순서나 타이밍에 따라 결괏값에 영향을 줄 수 있게 되는데 이를 **경쟁상태(Race Condition)**이라고 말합니다.



![](https://blog.kakaocdn.net/dn/zvgFi/btsHyuLNOPE/VC2Ztynz8FQofN2e5jcrQk/img.png)

추가로 이 공유자원에 접근하는 프로그램 코드 부분을 **임계 영역(Critical Area)**이라고 함.
  

즉, 공유자원에 여러 프로세스가 동시에 접근하게 되면 자료의 일관성을 해치는 결과가 나타날 수 있습니다.

  

예를 들어, 두 개의 스레드가 하나의 공유 자원인 전역 변수의 값을 증가시키는 상황을 가정해봅시다.

![](https://blog.kakaocdn.net/dn/dh9k1w/btsHzrggulk/MHsq49YLmAkYbezWkOWbp0/img.png)![](https://blog.kakaocdn.net/dn/bYzcOD/btsHxI4RGjh/DO33JTk2Akpy3KHFPjapAK/img.png)

경쟁상태 발생 X / 경쟁상태 발생 O

스레드 1이 실행되고 커밋된 이후에, 스레드 2가 실행되는 경우 경쟁상태가 발생하는 문제가 없이 의도한 대로 동작하는 것을 확인할 수 있지만, 오른쪽과 같이 스레드 1이 실행되는 도중에 스레드 2가 끼어들어 동시다발적으로 진행되는 경우 경쟁상태가 발생하여 의도한 결과를 얻지 못할 수 있습니다.

  

이처럼 프로세스나 스레드의 동작순서를 제어하지 않으면 경쟁상태가 발생할 수 있는데요. 

경쟁상태가 발생하게 되면, 예상되는 데이터의 값과 다른 데이터 정합성의 문제, 데이터 무결성의 문제(동시 다발적으로 하나의 계좌에서 출금 프로세스가 수행될 때 0원에서도 돈을 출금할 수 있는 상황)가 발생합니다.

  

아래의 조건들을 만족시켜 경쟁상태를 해결할 수 있습니다.

- **1. 상호 배제 ( Mutual Exclusion )** : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스가 들어가지 못하도록 하는 것
- **2. 한정 대기 ( Bounded Waiting )** : 특정 프로세스가 임계 영역 진입을 요청한 후 해당 요청이 승인되기 전까지 다른 프로세스가 임계영역에 진입하는 횟수를 제한하는 것.
    - 이를 통해 특정 프로세스가 영원히 임계 영역에 들어가지 못하게 하는 것을 방지.
- **3. 진행의 융통성 ( Progress )** : 지금 당장 어떠한 프로세스도 임계영역을 사용하지 않는다면, 임계 영역 외부의 어떠한 프로세스도 들어갈 수 있으며, 이 때 프로세스끼리 서로 방해하지 않는 것.

  

경쟁상태 문제가 발생하지 않도록 하기 위해서는 운영체제는 각 프로세스의 데이터와 물리적을 보호해야 하는데요. 운영체제는 이를 위해 대표적으로 **세마포어, 모니터, 뮤텍스**라는 세 가지 방법을 사용하여 위 조건들을 충족시켜 경쟁상태를 해결합니다. 지금부터 하나씩 알아봅시다.

  

## Race Condition Solution 1. 뮤텍스(Mutex)

![](https://blog.kakaocdn.net/dn/ChXjD/btsHyTYEirm/KJZ4Rqj80IKqgYmUMTKdZ1/img.png)

뮤텍스

- 공유 자원을 사용할 때 사용 전 lock()을 통해 잠금설정하고 사용한 후에 unlock()을 통해 잠금을 풀어, 사용하는 동안 다른 프로세스가 공유자원을 사용하지 못하도록 하는 전략입니다.
- Windows, Linux 등에서 기본적으로 제공되는 동기화 도구.
    - 이 때 락을 걸은 쓰레드만이 임계 구역을 나갈 때 락을 해제할 수 있습니다.
- 따라서 한 번에 하나의 프로세스만 임계영역에 진입할 수 있습니다.
- 한 프로세스가 임계영역에 들어갔을 때 다른 프로세스가 접근하지 못하게 하는 상호 배제 전략.
- 뮤텍스 접근 함수 : wait() - 뮤텍스 진입 요청,  unlock() - 뮤텍스 진출 요청

  

## Race Condition Solution 2. 세마포어 (Semaphore)

![](https://blog.kakaocdn.net/dn/caAIEt/btsHyYlj1XA/zwZGHK7dT4eTPF6DzRIvG0/img.png)

세마포어

- 일반화된 뮤텍스로, 정수 S와 wait(), signal()로 공유 자원에 대한 접근을 처리하는 전략입니다.
- 여러 개의 스레드나 프로세스가 동시에 접근할 수 있는 동기화 도구 
    - S는 현재 쓸 수 있는 공유 자원 수를 의미. 
        - S를 1로 설정한다면 뮤텍스처럼 사용할 수도 있지만, (전략이 다르기 때문에) 뮤텍스는 아님. - 이를 바이너리 세마포어라고 함.
    - 프로세스가 세마포어에 진입하기 위해 wait()을 호출하게 되면, S를 1 감소시킵니다. 이 때 S가 음수가 된다면 공유자원을 쓸 수 없기 때문에 프로세스의 진입을 차단하고 대기열에 해당 프로세스를 집어넣습니다. 
    - 프로세스가 세마포어 진입에 성공하여 공유자원을 다 쓰고 마치면, signal() 호출하여 S를 1 증가시키고 세마포어에서 나오게 함으로써 대기열에 있는 프로세스가 진입할 수 있도록 합니다.
- _뮤텍스와 달리 하나의 쓰레드 혹은 여러 개의 쓰레드가 들어가게 할 수 있는 것이 특징._
- _여러 개의 스레드가 동시에 특정 자원을 사용해야 하는 경우, 카운팅 세마포어를 사용하여 자원의 사용 가능한 개수를 조절할 수 있습니다. 이를 통해 스레드 간의 경쟁 상황을 줄이고, 자원의 사용을 효율적으로 관리할 수 있습니다._

|                              |                                                               |                                                           |
| ---------------------------- | ------------------------------------------------------------- | --------------------------------------------------------- |
| 차이점                          | 뮤텍스                                                           | 세마포어                                                      |
| 전략                           | **Locking 전략** : 락을 건 쓰레드만이 임계영역에서 나갈 때 unlock으로 락을 해제할 수 있다. | **Signaling 전략** : 락을 걸지 않은 쓰레드도 signal을 사용해 락을 해제할 수 있음. |
| 공유 자원 접근 가능  <br>프로세스/스레드 개수 | **오직 1개**                                                     | **세마포어 변수 S 수만큼.  <br>**                                  |

  

  

세마포어는 일반적으로 바이너리 세마포어, 카운팅 세마포어로 나뉨.

  

### 바이너리 세마포어

S에 0과 1 두 개의 값만 가질 수 있는 세마포어로 뮤텍스로 볼 수도 있지만 엄밀히 말하면 뮤텍스는 락 전략, 세마포어는 시그널링 전략을 사용하므로 뮤텍스로 볼 순 없습니다.

  

### 카운팅 세마포어

위에서 말한 일반적인 세마포어로 S에 2이상의 값을 가지는 세마포어.

  

## Race Condition Solution 3. 모니터 (Monitor)

![](https://blog.kakaocdn.net/dn/cfb8ds/btsHyFl8NGW/w3JXBrRa7vrPuRVC6GWJK1/img.png)

- 객체 지향 프로그래밍에서 사용되는 동기화 도구로, 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근하도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 전략입니다.
- 내부의 프로시저를 통해 하나의 스레드만 공유 자원에 접근하도록 조건 변수를 사용하여 스레드를 대기시키고 깨울 수 있습니다.

  

과정

1. 스레드가 모니터에 진입하려고 함.
2. 이 때 다른 스레드가 이미 락을 획득한 상태라면 현재 스레드는 대기하는데 대기 중인 스레드는 모니터 내부의 Waiting Queue에 저장. 만약 모니터 내의 조건 변수를 사용해 특정 조건이 만족될 때 까지 스레드를 대기시키고자 한다면, 이 경우에는 Waiting Queue가 아닌 Condition Waiting Queue에서 대기.
3. Queue에 들어간 스레드들은 우선 작업을 일시 중지 시키고 스레드 목록을 유지.
4. 스레드가 일시 중지된 상태에서 해당 조건이 충족되면, 모니터는 대기중인 스레드를 깨우고 다시 실행되도록 하여 모니터로 진입시킴.
5. 스레드가 모니터를 빠져나갈 때 락을 반납하여 다른 스레드들이 모니터에 진입할 수 있음.

- **뮤텍스와의 차이**
    - 모니터는 모니터큐에 작업을 순차적으로 쌓아두고, 한번에 한 프로세스/쓰레드만 임계 영역에 접근할 수 있도록 보장하여 개념적으로는 이진 세마포어, 뮤텍스 의 기능을 제공하는 것이지만, 뮤텍스는 다른 프로세스 간 동기화를 할 때 사용하여 커널에 의해 제공되므로 무겁고 느리지만, 모니터는 하나의 프로세스 내 다른 스레드 간 동기화에서 주로 사용되며, 가볍고 빠르다는 장점이 있습니다.   
          
        
- **세마포어와의 차이**  
    - 세마포어를 사용하기 위해서는 임계 구역에 명시적으로 상호 배제 로직을 구현해야 하지만, 모니터는 이 상호 배제 로직을 추상화하고, 공유 자원 접근에 대한 인터페이스만을 제공하고 공유 자원도 외부로부터 캡슐화하여 숨기기 때문에, 세마포어에 비해 좀 더 고수준이라고 할 수 있습니다. 
    - 세마포어는 정수 값과 두 가지 메소드 ( wait(), signal() )로 구성되어 있는 낮은 수준의 동기화 기본요소로 이루어진 반면, 모니터는 높은 수준의 동기화 추상화로, 객체 지향 프로그래밍 개념을 사용하여 공유 자원에 대한 접근을 제어한다는 점.

  

이렇게 경쟁상태와 경쟁 상태 해결 조건 세 가지에 대해 알아보았습니다.


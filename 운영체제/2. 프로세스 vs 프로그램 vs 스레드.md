## 프로세스와 프로그램의 차이

프로그램이 메모리에 적재되어 실행되고 있는 상태를 프로세스라고 말합니다.


> .exe 나 .dmg와 같은 파일 -> 프로그램 ( 정적인 상태 )  
> 이 프로그램을 실행시켜 메모리에 적재 -> 프로세스 ( 동적인 상태 )   
>   

- 모든 프로그램은 운영체제가 실행되기 위한 메모리 공간을 할당해주어야 실행될 수 있습니다. 

|   |   |
|---|---|
|프로세스|프로그램|
|실행되어 작업중인 프로그램|하나의 코드 덩어리가 컴파일 과정을 거쳐 실행파일로 만들어진 파일|
|파일이 메모리에 적재되어 실행되고 있는 상태|파일이 저장장치에 존재하지만 메모리에는 올라가 있지 않은 상태|
|||


  

![](https://blog.kakaocdn.net/dn/qUTpd/btsHsAT0VGl/xKYd66DlRrvLq5NcUb4or0/img.png)![](https://blog.kakaocdn.net/dn/l11Ah/btsHsr3XAlf/oamJP3GKNgE6dLQ1XOEA6k/img.png)


  

그렇다면 프로세스와 스레드는 차이는 무엇일까

  

## 프로세스와 스레드 차이

스레드는 프로세스 내 작업의 흐름을 지칭합니다.

  

|   |   |
|---|---|
|프로세스|스레드|
|OS로부터 자원을 할당받은 **작업의 단위**로 메모리에 프로그램이 적재되어 있는 상태.|프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위  <br>**|
|다른 프로세스와 격리되어 있기 때문에 프로세스간 통신을 하기 위해서는 IPC를 사용해야 함.|다른 스레드와 격리되어 있지 않으므로 그냥 통신할 수 있으므로 프로세스보다 속도가 빠름.|
|다른 프로세스와 독립적이므로 문제가 생긴다고 해서 다른 프로세스에 영향을 주진 않음.|한 스레드에 문제가 생기면 동일 프로세스 내의 다른 스레드와 프로세스에 영향을 줄 수 있음.|
|생성과 종료에 더 많은 시간이 소요.|생성과 종료에 비교적 적은 시간이 소요|

  

조금 더 쉽게 말하자면 스레드는 프로세스에서 할당받은 자원을 이용하여 하나의 프로세스에서의 일련의 작업들을 진행하는 단위로, 스레드가 하나가 있다면 싱글 스레드, 여러개 있다면 멀티 스레드라고 부릅니다.

  

![](https://blog.kakaocdn.net/dn/bgIu5s/btsHts1QGdk/caTNBGgP2umlKIUDtFjsiK/img.png)

프로세스와 스레드

  

## 프로그램의 컴파일 과정

![](https://blog.kakaocdn.net/dn/HLQxJ/btsHukoo0RZ/Hr6mPSFdWHdBrRNCE22ZZk/img.png)

프로그램의 컴파일 과정

### 1. 전처리기 ( Preprocessor )

![](https://blog.kakaocdn.net/dn/dl6yMj/btsHtiyu2Uj/Yiycz8TaLrTxmkkr3TxtnK/img.png)

- 소스코드의 주석 제거, 헤더파일 병합. 매크로 치환하여 컴파일할 수 있는 *.i 파일을 생성

  

### 2. 컴파일러 ( Compiler )

- 전처리기에서 만들어진 *.i 파일의 오류를 처리하고, 코드를 최적화 하는 작업을 하여 어셈블리어로 변환한 *.s file 을 생성

  

### 3. 어셈블러 ( Assembler )

- 어셈블리어로 작성된 *.s file을  *.o 목적 파일을 생성

  

### 4. 링커

- 목적 파일을 통해 실행할 수 있는 *.exe, *.out 확장자의 프로그램을 생성

  

## 프로세스의 메모리 구조 

![](https://blog.kakaocdn.net/dn/boQ9OE/btsHucjGQoX/oDANq3sV2VAfk5TKXOGmm0/img.png)

프로세스의 메모리 구조

  

운영체제는 프로그램이 실행되어 프로세스가 되면 프로세스에 적절한 메모리를 할당합니다.

영역으로 구분하면 스택 영역, 힙 영역, 데이터 영역(BSS/Data Segment), 코드 영역으로 구분합니다.

  

- **스택 영역** : 지역변수, 매개변수, 함수가 저장. 컴파일 시 크기가 결정지만, 함수가 함수를 호출하는 재귀 함수같은 경우는 런타임 시 크기가 변경됨. (동적)
    - 지역변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역으로, 재귀 함수의 경우 매번 새로운 스택 프레임이 사용되기 때문에 함수 내의 변수 집합이 해당 함수의 다른 인스턴스 변수를 방해하지 않음.
- **힙 영역** : 동적 할당할 때 사용되는 영역으로 런타임 시 크기가 결정 (동적)
    - malloc(), free() 함수를 통해 할당하고 해제하며 동적으로 관리할 수 있으며, 동적으로 관리되는 자료구조 (ex : Cpp의 vector, Java의 Collection)가 이 힙 영역에 저장됩니다.
- **데이터 영역** : 코드가 실행되면서 사용되는 전역 변수가 저장된 영역으로 BSS Segment와 Data Segment로 구분. (정적)
    - _BSS Segment : 0으로 초기화되거나 초기화 되지 않은 전역 변수, static, const로 선언된 변수가 저장되는 영역_
    - _Data Segment : 0이 아닌 값으로 초기화된 전역 변수, static, const로 선언된 변수가 저장되는 영역_
- **코드 영역** : 소스코드가 CPU가 해석할 수 있는 기계어 형태로 저장되어 있는 영역. (정적)

  

### 스레드는 힙 영역, 데이터 영역, 코드 영역을 공유한다!

![](https://blog.kakaocdn.net/dn/nhrvQ/btsHubE74lc/JThe0VbzQk1AmdMD0dkT1k/img.png)

프로세스, 스레드의 메모리 영역

  

- 하나의 프로세스에서 파생된 스레드들은 프로세스에서 사용되는 메모리 영역 중 스택 영역을 제외한 힙, 데이터, 코드 영역을 공유해서 사용하고, 스택 영역은 각각의 스레드가 각각 별도로 가집니다.
- 스레드는 각각의 스택을 가짐으로써 독립적인 함수 호출이 가능하며, 이에 따라 독립적인 실행흐름을 가질 수 있겠습니다.

  

## PCB (Process Control Block)

- 프로세스에 대한 메타 데이터를 저장하고 있는 데이터 블록으로 커널 스택에 저장됩니다.
- 각 프로세스마다 고유의 PCB가 생성되고, 프로세스가 종료되면 PCB가 제거됨.

> [커널 스택]  
> - 가상 메모리는 스택구조로 되어 있는 사용자 공간과 커널 공간으로 구분되며, 사용자 스택 - 커널 스택으로 부르기도 함.  
> - 커널 스택 : 커널 모드에서만 접근 가능  
> - 사용자 스택 : 사용자 모드에서만 접근 가능

  

### PCB의 구조 

![](https://blog.kakaocdn.net/dn/bXk5pn/btsHt1QafU7/PRgBT3E7hXs8oz5j7DS4Y0/img.png)

- **프로세스의 상태** : 대기중, 실행 중 등 프로세스의 상태
- **프로세스 번호** : 각 프로세스의 고유 식별 번호 (Process ID, PID)
- **프로그램 카운터** : 이 프로세스에 대하여 실행될 다음 명령어의 주소에 대한 포인터. (Program Counter, PC)
- **레지스터 관련 정보**
- **메모리 제한 정보** : 프로세스의 메모리 관련 정보
- **열린 파일 정보** : 프로세스를 위해 열린 파일 목록

  

## Context Switching

**컨텍스트 스위칭**은 CPU가 한 프로세스에서 다른 프로세스로 전환하기 위해 PCB를 기반으로 프로세스의 상태를 저장하고 다시 복원시키는 일련의 과정으로, 여러 개의 프로세스를 번갈아가며 실행하여 CPU 활용률을 높이기 위해 필요하며, 프로세스가 종료되거나, 인터럽트에 의해 발생되기도 합니다.

  

![](https://blog.kakaocdn.net/dn/bteXfM/btsHtIDzzoS/o2UR9Hx1Uc5ZzPeTzFcxTk/img.png)

1. 프로세스 1이 실행 중에 인터럽트 발생 -> 프로세스 1의 상태를 PCB에 저장.
2. CPU가 놀지 않도록 하기 위해 프로세스 2의 상태를 PCB로부터 불러와 CPU에 로딩.
3. 인터럽트 종료 -> 프로세스 1을 다시 CPU에 올려야 함.
4. 프로세스 1을 CPU에 올리기 위해 인터럽트를 발생시켜 PCB에 프로세스 2의 상태 저장.
5. 프로세스 1를 불러오기 위해 PCB로부터 상태를 불러옴.
6. 프로세스 1을 CPU에 로딩

  

### 컨텍스트 스위칭에서 발생하는 비용

![](https://blog.kakaocdn.net/dn/bpcqUd/btsHsp6buiF/KKknIiKDrwSRkPKvm8W2LK/img.png)

1. 유휴시간의 발생 

- 컨텍스트 스위칭을 할 때 마다 유휴시간( CPU가 일을 하지 않고 쉬는 시간 )이 생겨 CPU의 가용성이 떨어지는 비용이 발생.

  

2. 캐시 미스

- 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소변환이 생겨 TLB 계층에서 주소변환을 위해 기존의 주소를 제거하는 캐시 클리어 과정이 일어나, 캐시미스가 발생. 

  

3. 오버헤드

- PCB를 저장하고, 불러오는 비용
- 스케줄링에 대한 비용

> - 스레드 간의 컨텍스트 스위칭 비용/시간 < 프로세스 간 컨텍스트 스위치 비용/시간   
> >> 아무래도 스레드끼리는 스택영역을 제외하고는 모두 같은 공간을 공유하다보니, 프로세스에 비해 컨텍스트 스위칭 비용과 시간이 적다는 장점이 있습니다.

  

## 프로세스 상태

![](https://blog.kakaocdn.net/dn/cejCcT/btsHuNjsPcR/DnKk2i0pHtQ9TpTWCawek1/img.png)

프로세스가 실행되는 동안 변경되는 고유 상태를 말합니다. PCB에 저장되며, 일반적으로 5가지의 상태를 가집니다.

  

- **생성 (NEW)** : 프로세스가 생성된 상태로 PCB만 할당된 상태. fork(), exec()와 같은 호출을 통해 프로세스가 생성되기만 한 상태. 
- **준비 (READY)** : 실행을 위해 기다리는 상태로, 준비 큐에 들어가서 대기하면서 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태.
- **실행 (RUNNING)** : CPU 소유권과 메모리를 할당받아, 명령어들을 수행중인 상태.
- **대기 (WAITING)** : 프로세스 실행 도중 (입출력과 같은) 이벤트가 발생하여 잠시 중단된 상태
- **종료 (EXIT)** : 프로세스가 실행을 완료하고 종료된 상태로, 메모리에서 제거되며, CPU 소유권을 잃은 상태.
